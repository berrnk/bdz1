# УЧЕТ ФИНАНСОВ

## 1. Общая идея решения

В данном проекте реализован модуль «Учет финансов», который предоставляет следующий функционал:

1. **Управление счетами (BankAccount)**  
   - Создание, редактирование и удаление счетов  
   - Поддержка баланса (при операциях дохода/расхода баланс автоматически пересчитывается)

2. **Управление категориями (Category)**  
   - Создание, редактирование и удаление категорий (доходы/расходы)

3. **Управление операциями (Operation)**  
   - Создание, редактирование и удаление операций  
   - Автоматический пересчет баланса для связанных счетов

4. **Аналитика**  
   - Подсчет разницы доходов и расходов за выбранный период  
   - Группировка операций по категориям (доходы/расходы)

5. **Импорт и экспорт данных**  
   - Экспорт данных в CSV, JSON, YAML (через паттерн «Посетитель»)  
   - Импорт данных из CSV, JSON, YAML (через паттерн «Шаблонный метод»)

6. **Измерение времени выполнения** пользовательских сценариев (например, создание счета) с помощью паттерна «Команда» и «Декоратор».

7. **Консольный интерфейс** для демонстрации всех возможностей модуля.

> **Изменения в функциональных требованиях:**  
> - Добавлен механизм фабрики для единообразного создания доменных объектов с валидацией.  
> - Разделение приложения на несколько слоёв (Domain, Infrastructure, Application, Presentation) для лучшей архитектуры и соблюдения SOLID/GRASP.  
> - Возможность в любой момент вернуться в главное меню или «выйти» из процесса ввода.  

---

## 2. Принципы SOLID и GRASP

### 2.1. SOLID

1. **Single Responsibility Principle (SRP)**  
   Каждый класс отвечает за одну задачу. Например,  
   - `BankAccount` хранит данные о счёте и не занимается импортом/экспортом.  
   - `FinancialFacade` управляет бизнес-операциями с доменными объектами.  

2. **Open/Closed Principle (OCP)**  
   Код легко расширяется, но закрыт для изменений базовых модулей.  
   - При добавлении нового формата импорта (XML) достаточно создать класс, унаследованный от `DataImporter`, не меняя существующий код.  

3. **Liskov Substitution Principle (LSP)**  
   Наследники корректно подменяют базовые типы.  
   - `CsvDataImporter`, `JsonDataImporter`, `YamlDataImporter` корректно реализуют абстрактный класс `DataImporter`.  

4. **Interface Segregation Principle (ISP)**  
   Интерфейсы не должны быть «толстыми».  
   - `ICommand` содержит единственный метод `Execute()`.  
   - `IExportVisitor` состоит из методов `Visit(...)` для различных доменных объектов.  

5. **Dependency Inversion Principle (DIP)**  
   Модули верхнего уровня зависят от абстракций, а не от деталей.  
   - Импортеры/экспортеры работают через абстрактные классы и интерфейсы (`DataImporter`, `IExportVisitor`).  
   - Использование DI-контейнера (например, Microsoft.Extensions.DependencyInjection) упрощает настройку зависимостей.

### 2.2. GRASP

1. **High Cohesion**  
   - Классы сгруппированы по смыслу: фасад для операций с доменными объектами, отдельные классы для импорта/экспорта, фабрика для создания объектов.  

2. **Low Coupling**  
   - Взаимодействие классов идёт через фасады и абстракции. Консольное приложение не знает деталей импорта или экспорта, а вызывает методы фасада.  

3. **Creator**  
   - `DomainFactory` отвечает за создание объектов (BankAccount, Category, Operation) и валидацию данных (например, запрет на отрицательный баланс).  

4. **Controller**  
   - Класс `FinancialFacade` является «координатором» для операций с доменными объектами, предоставляя единый интерфейс для консольного приложения.  

5. **Pure Fabrication**  
   - `FinancialFacade` не относится к предметной области напрямую, но решает архитектурные задачи по упрощению взаимодействия с доменными сущностями.

---

## 3. Паттерны GoF

1. **Фабрика (Factory Pattern)**  
   - **Реализация**: `DomainFactory`  
   - **Важность**:  
     - Централизует создание объектов  
     - Упрощает валидацию (например, запрет на отрицательные суммы)  

2. **Фасад (Facade Pattern)**  
   - **Реализация**: `FinancialFacade`  
   - **Важность**:  
     - Предоставляет единый интерфейс для управления счетами, категориями, операциями, аналитикой  
     - Уменьшает связанность  

3. **Команда (Command Pattern)**  
   - **Реализация**: интерфейс `ICommand` + команды (например, `CreateAccountCommand`)  
   - **Важность**:  
     - Каждую операцию (сценарий) можно представить как объект команды  
     - Легко расширять функционал (новые команды)  

4. **Декоратор (Decorator Pattern)**  
   - **Реализация**: `TimeMeasuredCommandDecorator`  
   - **Важность**:  
     - Добавляет измерение времени без изменения кода команды  
     - Удобно для логирования и метрик  

5. **Шаблонный метод (Template Method)**  
   - **Реализация**: абстрактный класс `DataImporter`  
   - **Важность**:  
     - Общее поведение (чтение файла, сохранение) + специфичный парсинг (CSV, JSON, YAML)  
     - Исключает дублирование кода  

6. **Посетитель (Visitor Pattern)**  
   - **Реализация**: `IExportVisitor` + конкретные экспортеры (CSV, JSON, YAML)  
   - **Важность**:  
     - Позволяет добавлять новые форматы экспорта без изменения доменных классов  
     - Легко расширять функционал экспорта  

7. **Прокси (Proxy Pattern)**  
   - **Реализация**: `DataContext` как in‑memory хранилище  
   - **Важность**:  
     - Скрывает реализацию хранения  
     - Можно переключиться с in‑memory на реальную БД, не меняя логику бизнес-уровня  

---

## 4. Инструкция по запуску приложения

1. **Клонируйте репозиторий:**
```bash
git clone https://github.com/M1steryO/FinancialAccounting.git
```
2. **Перейдите в директорию проекта:** 
```bash
cd FinancialAccounting
```
3. **Убедитесь, что у вас установлен .NET SDK (версия 6.0)**
4. **Соберите решение:**
```bash
dotnet build
```
5. **Перейдите в директорию консольного приложения:**
```bash
cd FinancialAccounting.ConsoleApp
```
6. **Запустите приложение:**
```bash
dotnet run
```